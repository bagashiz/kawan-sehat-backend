// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: replies.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countRepliesByCommentID = `-- name: CountRepliesByCommentID :one
SELECT COUNT(*) FROM replies
WHERE comment_id = $1
`

func (q *Queries) CountRepliesByCommentID(ctx context.Context, commentID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countRepliesByCommentID, commentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteReply = `-- name: DeleteReply :execrows
DELETE FROM replies
WHERE id = $1
`

func (q *Queries) DeleteReply(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReply, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const insertReply = `-- name: InsertReply :exec
INSERT INTO replies (
    id, account_id, comment_id, content, created_at
) VALUES (
  $1, $2, $3, $4, $5
)
`

type InsertReplyParams struct {
	ID        uuid.UUID
	AccountID uuid.UUID
	CommentID uuid.UUID
	Content   string
	CreatedAt time.Time
}

func (q *Queries) InsertReply(ctx context.Context, arg InsertReplyParams) error {
	_, err := q.db.Exec(ctx, insertReply,
		arg.ID,
		arg.AccountID,
		arg.CommentID,
		arg.Content,
		arg.CreatedAt,
	)
	return err
}

const selectRepliesByCommentID = `-- name: SelectRepliesByCommentID :many
SELECT r.id, r.comment_id, r.account_id, r.content, r.created_at, 
       a.username AS account_username, a.avatar AS account_avatar, a.role AS account_role, 
       (SELECT COALESCE(SUM(v.value), 0) FROM votes v WHERE v.reply_id = r.id) AS total_votes,
       COALESCE((SELECT v.value FROM votes v WHERE v.reply_id = r.id AND v.account_id = $1), 0) AS vote_state
FROM replies r
JOIN accounts a ON r.account_id = a.id
WHERE r.comment_id = $2
ORDER BY total_votes
`

type SelectRepliesByCommentIDParams struct {
	AccountID uuid.UUID
	CommentID uuid.UUID
}

type SelectRepliesByCommentIDRow struct {
	ID              uuid.UUID
	CommentID       uuid.UUID
	AccountID       uuid.UUID
	Content         string
	CreatedAt       time.Time
	AccountUsername string
	AccountAvatar   AccountAvatar
	AccountRole     AccountRole
	TotalVotes      interface{}
	VoteState       interface{}
}

func (q *Queries) SelectRepliesByCommentID(ctx context.Context, arg SelectRepliesByCommentIDParams) ([]SelectRepliesByCommentIDRow, error) {
	rows, err := q.db.Query(ctx, selectRepliesByCommentID, arg.AccountID, arg.CommentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectRepliesByCommentIDRow{}
	for rows.Next() {
		var i SelectRepliesByCommentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CommentID,
			&i.AccountID,
			&i.Content,
			&i.CreatedAt,
			&i.AccountUsername,
			&i.AccountAvatar,
			&i.AccountRole,
			&i.TotalVotes,
			&i.VoteState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRepliesByCommentIDPaginated = `-- name: SelectRepliesByCommentIDPaginated :many
SELECT r.id, r.comment_id, r.account_id, r.content, r.created_at,
       a.username AS account_username, a.avatar AS account_avatar, a.role AS account_role, 
       (SELECT COALESCE(SUM(v.value), 0) FROM votes v WHERE v.reply_id = r.id) AS total_votes,
       COALESCE((SELECT v.value FROM votes v WHERE v.reply_id = r.id AND v.account_id = $1), 0) AS vote_state
FROM replies r
JOIN accounts a ON r.account_id = a.id
WHERE r.comment_id = $2
ORDER BY total_votes
LIMIT $3
OFFSET $4
`

type SelectRepliesByCommentIDPaginatedParams struct {
	AccountID uuid.UUID
	CommentID uuid.UUID
	Limit     int32
	Offset    int32
}

type SelectRepliesByCommentIDPaginatedRow struct {
	ID              uuid.UUID
	CommentID       uuid.UUID
	AccountID       uuid.UUID
	Content         string
	CreatedAt       time.Time
	AccountUsername string
	AccountAvatar   AccountAvatar
	AccountRole     AccountRole
	TotalVotes      interface{}
	VoteState       interface{}
}

func (q *Queries) SelectRepliesByCommentIDPaginated(ctx context.Context, arg SelectRepliesByCommentIDPaginatedParams) ([]SelectRepliesByCommentIDPaginatedRow, error) {
	rows, err := q.db.Query(ctx, selectRepliesByCommentIDPaginated,
		arg.AccountID,
		arg.CommentID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectRepliesByCommentIDPaginatedRow{}
	for rows.Next() {
		var i SelectRepliesByCommentIDPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.CommentID,
			&i.AccountID,
			&i.Content,
			&i.CreatedAt,
			&i.AccountUsername,
			&i.AccountAvatar,
			&i.AccountRole,
			&i.TotalVotes,
			&i.VoteState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectReplyByID = `-- name: SelectReplyByID :one
SELECT id, comment_id, account_id, content, created_at FROM replies
WHERE id = $1
`

func (q *Queries) SelectReplyByID(ctx context.Context, id uuid.UUID) (Reply, error) {
	row := q.db.QueryRow(ctx, selectReplyByID, id)
	var i Reply
	err := row.Scan(
		&i.ID,
		&i.CommentID,
		&i.AccountID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}
